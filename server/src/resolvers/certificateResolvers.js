const Certificate = require('../models/Certificate');
const { UserInputError } = require('apollo-server-express');
const { generateCertificateNumber } = require('../utils/certificateNumberGenerator');

const certificateResolvers = {
   Query: {
      getCertificates: async (_, { status }) => {
         try {
            const query = status ? { status } : {};
            return await Certificate.find(query).sort({ createdAt: -1 });
         } catch (error) {
            throw new Error(`Failed to fetch certificates: ${error.message}`);
         }
      },
      getCertificateById: async (_, { id }) => {
         try {
            return await Certificate.findById(id);
         } catch (error) {
            throw new Error(`Failed to fetch certificate: ${error.message}`);
         }
      },
      getCertificatesByApplicationId: async (_, { applicationId }) => {
         try {
            return await Certificate.find({ applicationId });
         } catch (error) {
            throw new Error(`Failed to fetch certificates: ${error.message}`);
         }
      }
   },

   Mutation: {
      generateCertificate: async (_, { input }) => {
         try {
            const certificateNumber = await generateCertificateNumber(input.applicationType);

            const certificate = new Certificate({
               ...input,
               certificateNumber,
               status: 'Pending Signature',
               history: [{
                  action: 'GENERATED',
                  timestamp: new Date(),
                  notes: 'Certificate generated by technical staff'
               }]
            });

            const savedCertificate = await certificate.save();
            return savedCertificate;
         } catch (error) {
            console.error('Error generating certificate:', error);
            throw new Error(`Failed to generate certificate: ${error.message}`);
         }
      },

      forwardCertificateForSignature: async (_, { id }) => {
         try {
            const certificate = await Certificate.findById(id);
            if (!certificate) {
               throw new UserInputError('Certificate not found');
            }

            certificate.history.push({
               action: 'FORWARDED',
               timestamp: new Date(),
               notes: 'Forwarded for signature to PENRO'
            });

            return await certificate.save();
         } catch (error) {
            throw new Error(`Failed to forward certificate: ${error.message}`);
         }
      },

      signCertificate: async (_, { id, signature }) => {
         try {
            const certificate = await Certificate.findById(id);
            if (!certificate) {
               throw new UserInputError('Certificate not found');
            }

            certificate.signedBy = {
               PENRO: {
                  signature,
                  dateSigned: new Date()
               }
            };
            certificate.status = 'Signed';
            certificate.dateIssued = new Date();
            certificate.expiryDate = new Date(Date.now() + 365 * 24 * 60 * 60 * 1000); // 1 year from now

            certificate.history.push({
               action: 'SIGNED',
               timestamp: new Date(),
               notes: 'Certificate signed by PENRO'
            });

            return await certificate.save();
         } catch (error) {
            throw new Error(`Failed to sign certificate: ${error.message}`);
         }
      }
   }
};

module.exports = certificateResolvers;
